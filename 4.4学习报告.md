# 第五次报告
---
## 排序（下）
 
 ### 六、快速排序
 基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

6.1 算法描述
快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：

从数列中挑出一个元素，称为 “基准”（pivot）；
重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。
在这个分区退出之后，该基准就处于数列的**中间位置**。这个称为分区（partition）操作；
**递归地**（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
上次报告发现，github不支持HTML，不过这个文章我还是会看的，所以还会把gif放上来。

<iframe height=270 width=830 src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif"></iframe>

```C
int QuickSort(int *arr,int left,int right)
//快速排序法 （指定数组，数组左端，数组右端）
{
    int f,t;//设置基准和中间量（交换数据时使用）
    int rtemp,ltemp;//设右当前指向数组的位置（以下称右当前）和左当前指向数组的位置（以下称左当前）
    ltemp=left;//初始令左当前为数组最左端
    rtemp=right;//初始令右当前为数组最右端
    f=arr[(left+right)/2];//不妨设基准为数组中间位置的数据（偶数个数据的数组为中间靠左的位置）
    while(ltemp<rtemp)//当左当前在右当前左端时，进行循环
    {
        while(arr[ltemp]<f)//当左当前位置对应数据小于基准时，进行循环
        {
            ++ltemp;//使左当前向右移一位
        }//直到左当前位置对应数据大于基准时跳出循环，此时应该将此数据交换到基准右边
        while(arr[rtemp]>f)//当右当前位置对应数据大于基准时，进行循环
        {
            --rtemp;//使右当前向左移一位
        }//直到右当前位置对应数据小于基准时跳出循环，此时应该将此数据交换到基准左边
        if(ltemp<=rtemp)//此时应进行数据交换，判断左当前是否还在右当前左边，若是则进行以下步骤
        {
            t=arr[ltemp];
            arr[ltemp]=arr[rtemp];
            arr[rtemp]=t;//以上三行为交换左当前和右当前分别对应的数据
            --rtemp;//右当前左移一位
            ++ltemp;//左当前右移一位
        }//若此判断条件不成立，则可直接进行以下步骤
    }
    if(ltemp==rtemp)//排除左当前和右当前指向同一位置的干扰
        ltemp++;
    if(left<rtemp)//若右当前仍未移到数组最左端
        QuickSort(arr,left,ltemp-1);//运用递归的方式将数组左端和左当前-1之间的数据重新排序
    if(ltemp<right)//若左当前仍未移到数组最右端
        QuickSort(arr,rtemp+1,right);//运用递归的方式将数组右当前+1和右端之间的数据重新排序
 
 //重复使用递归后排序结束
	
	return 0;
}

```

---
### 七、堆排序
堆排序（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

在堆的数据结构中，堆中的最大值总是位于根节点（在优先队列中使用堆的话堆中的最小值位于根节点）。堆中定义以下几种操作：

* 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；
* 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；
* 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。

<iframe height=370 width=550 src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231308699-356134237.gif"></iframe>

```C
/*堆调整，构建大顶堆，arr[]是待调整的数组，i是待调整的数组元素的位置，
length是数组的长度*/
void HeapAdjust(int arr[], int i, int length)
{
    int Child;
    int temp;
    for(;2 * i + 1 < length; i = Child)
    {
        //子节点的位置 = 2 * (parent(父结点)) + 1
        Child = 2 * i + 1;
        //得到子结点中较大的结点
        if(Child < length - 1 && arr[Child + 1] > arr[Child])
        ++Child;
        //如果较大的子结点大于父结点那么把较大的子结点往上移动
        //替换它的父结点
        if(arr[i] < arr[Child])
        {
            temp = arr[i];
            arr[i] = arr[Child];
            arr[Child] = temp;
        }
        else
            break;
    }
}
//堆排序算法
void heap_sort(int arr[], int length)
{
    int i;
    //调整序列的前半部分元素，调整完之后第一个元素
    //是序列的最大元素，length/2-1是最后一个非叶子结点
    for(i = length/2 - 1; i >= 0; --i)
        HeapAdjust(arr, i, length);
    //从最后一个元素开始对序列进行调整，不断的缩小调整
    //的范围直到第一个元素
    //循环里是把第一个元素和当前的最后一个元素交换
    //保证当前的最后一个位置的元素是现在这个序列的最大的
    //不断的缩小调整heap的范围，每一次调整完毕保证第一个
    //元素是当前序列的最大的元素
    for(i = length - 1; i > 0; --i)
    {
        arr[i] = arr[0]^arr[i];
        arr[0] = arr[0]^arr[i];
        arr[i] = arr[0]^arr[i];
        //通过异或运算交换arr[i]与arr[0]的值
        HeapAdjust(arr, 0, i);    
        //递归调整
    }

 
```
今天我知道一件事情觉得非常恐怖，那就是，我可能，疑似，知道了是谁，在看我写什么，总觉得非常，羞愧。。。
